## 初步想法
### 长网址->短网址
计算长网址hash值作为短网址，并将映射关系持久化到数据库中。

hash算法可以选择 Murmurhash 32位，并将结果转换为62进制，缩短短网址长度。

### 短网址->长网址
通过短网址hash值查询数据库并返回结果。

## 主要方案
### 长网址->短网址
长网址转短网址会存在hash冲突的问题，需要添加一个salt重新hash。

大致有几种方案：
- 方案1
	- 通过url查询记录 （查询一次，全表扫描）
		- 记录存在
			- 返回结果
		- 记录不存在
			- 插入记录（插入一行）
				- 插入成功
					- 返回结果
				- 插入失败
					- hash冲突 加salt重新hash
					- 未知错误
- 方案2
	- 通过hash查询记录 （查询一次，扫描一行）
		- 记录存在
			- url是否一致
				- 是 返回结果
				- 否 加salt重新hash，递归
		- 记录不存在
			- 插入记录（插入一行）
				- 插入成功
					- 返回结果
				- 插入失败
					- 未知错误
- 方案3
	- 插入记录（插入一行）
		- 插入成功
			- 返回结果
		- 插入失败
			- hash不是唯一
				- 通过hash查询记录 （查询一次，扫描一行）
					- 记录必定存在
						- 是否hash冲突
							- 是 返回结果
							- 否 加salt重新hash，递归
			- 未知错误
- 方案4
	- 插入记录（插入一行）
		- 插入成功
			- 返回结果
		- 插入失败
			- hash不是唯一
				- 通过url查询记录 （查询一次，全表扫描）
					- 记录存在
						- 返回结果
					- 记录不存在
						- 加salt重新hash，递归
			- 未知错误

方案1查询url，但是url不能做索引，查询时只能做全表扫描，效率不高。

方案2通过该查询url为hash，避免全表扫描。

方案3通过对方案2的流程做优化，只会在hash记录已存在的情况下执行两条SQL语句，在一般情况下优于方案2的只在hash记录已存在时才执行一条SQL语句。

方案4是为了解决方案2和3同时存在的一个问题。如果两个长网址存在hash冲突，那么另一个长网址生成时会被不断加salt，并新增一条记录。也就是说，每次都会生成新的短网址。但是方案4会出现url字段全表扫描的情况。


### 短网址->长网址
通过hash查询出短网址即可，hash字段需添加索引避免全表扫描。

## 其他方案
- 通过ID生成器分配短网址
	- 优点 通过MySQL自增ID实现可以十分简单
	- 缺点 只能按规律生成

## 综合评估
短网址服务主要技术点在于长网址转短网址的过程，并且每种方案有各自的优点。

综合考虑我会选择方案4，为了避免同一个长网址生成不同短网址，在hash不唯一时做一次全部扫描查询是可以被我接受的。